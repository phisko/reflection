function(putils_generate_reflection_headers)
    set(options)
    set(oneValueArgs TARGET EXTENSION)
    set(multiValueArgs SOURCES CLANG_ARGS)
    cmake_parse_arguments(ARGUMENTS "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

    function(check_argument arg_name)
        if(NOT ARGUMENTS_${arg_name})
            message(FATAL_ERROR "Missing ${arg_name} argument to putils_generate_reflection_headers")
        endif()
    endfunction()

    check_argument(TARGET)
    check_argument(SOURCES)

    set(python_script ${CMAKE_CURRENT_FUNCTION_LIST_DIR}/generate_reflection_headers.py)

    # Build clang arguments
    set(clang_args)
    get_target_property(cxx_version ${ARGUMENTS_TARGET} CXX_STANDARD)
    list(APPEND clang_args -std=c++${cxx_version})
    list(APPEND clang_args ${ARGUMENTS_CLANG_ARGS})

    # All include directories for the target, prefixed with '-I' and separated by a space
    set(include_directories $<TARGET_PROPERTY:${ARGUMENTS_TARGET},INCLUDE_DIRECTORIES>)
    set(include_directories $<REMOVE_DUPLICATES:${include_directories}>)
    list(APPEND clang_args "-I$<JOIN:${include_directories}, -I>")

    # All compile definitions for the target, prefixed with '-D' and separated by a space
    set(compile_definitions $<TARGET_PROPERTY:${ARGUMENTS_TARGET},COMPILE_DEFINITIONS>)
    set(compile_definitions $<REMOVE_DUPLICATES:${compile_definitions}>)
    list(APPEND clang_args "-D$<JOIN:${compile_definitions}, -D>")

    # Get the export headers generated by putils_export_symbols.cmake
    set(processed)
    function(get_export_headers out_var_name target)
        if (NOT TARGET ${target})
            return()
        endif()

        set(out_list)

        get_target_property(export_file_name ${target} PUTILS_EXPORT_FILE_NAME)
        if(NOT "${export_file_name}" STREQUAL export_file_name-NOTFOUND)
            list(APPEND out_list ${export_file_name})
        endif()

        get_target_property(dependencies ${target} LINK_LIBRARIES)
        if("${dependencies}" STREQUAL dependencies-NOTFOUND)
            set(dependencies)
        endif()

        get_target_property(interface_dependencies ${target} INTERFACE_LINK_LIBRARIES)
        if(NOT "${interface_dependencies}" STREQUAL interface_dependencies-NOTFOUND)
            list(APPEND dependencies ${interface_dependencies})
        endif()

        list(REMOVE_DUPLICATES dependencies)

        foreach(dependency ${dependencies})
            if (${dependency} IN_LIST processed)
                continue()
            endif()
            list(APPEND processed ${dependency})
            set(processed ${processed} PARENT_SCOPE)

            get_export_headers(dependency_export_headers ${dependency})
            list(APPEND out_list ${dependency_export_headers})
        endforeach()

        list(REMOVE_DUPLICATES out_list)
        set(${out_var_name} ${out_list} PARENT_SCOPE)
    endfunction()

    # Force include export headers
    get_export_headers(export_headers ${ARGUMENTS_TARGET})
    foreach(header ${export_headers})
        list(APPEND clang_args -include ${header})
    endforeach()

    # Get only header files
    set(headers)
    foreach(file ${ARGUMENTS_SOURCES})
        get_filename_component(extension ${file} EXT)
        if (${extension} STREQUAL ".hpp")
            list(APPEND headers ${file})
        endif()
    endforeach()

    # Add a command for each reflection header we need to generate
    # This lets us have "atomic" commands that only run when their specific header is modified
    # Each command will create a "time_marker_file" used as a timestamp for the last time reflection code was generated
    set(time_marker_files)
    foreach(header ${headers})
        set(command ${PYTHON_EXECUTABLE} ${python_script} ${header} --clang-args ${clang_args})
        if (${ARGUMENTS_EXTENSION})
            list(APPEND command --extension ${ARGUMENTS_EXTENSION})
        endif()

        # Dummy file to avoid re-running the command if `header` hasn't changed
        get_target_property(binary_dir ${ARGUMENTS_TARGET} BINARY_DIR)
        get_target_property(source_dir ${ARGUMENTS_TARGET} SOURCE_DIR)
        file(RELATIVE_PATH header_relative_path ${source_dir} ${header})
        set(time_marker_file ${binary_dir}/${header_relative_path}.generated_reflection)

        get_filename_component(time_marker_directory ${time_marker_file} DIRECTORY)

        add_custom_command(
                OUTPUT ${time_marker_file}
                COMMENT "Generating reflection code for ${header}"
                # COMMAND ${CMAKE_COMMAND} -E echo "Generating reflection code for ${header}"
                COMMAND ${command}
                COMMAND ${CMAKE_COMMAND} -E make_directory ${time_marker_directory}
                COMMAND ${CMAKE_COMMAND} -E touch ${time_marker_file}
                DEPENDS ${header} ${python_script}
        )
        list(APPEND time_marker_files ${time_marker_file})
    endforeach()

    # Create a new target depending on all the time marker files, and depended upon by `ARGUMENTS_TARGET`
    set(reflection_target ${ARGUMENTS_TARGET}_reflection)
    add_custom_target(
            ${reflection_target}
            COMMENT "Generated reflection code for ${ARGUMENTS_TARGET}"
            DEPENDS ${time_marker_files}
    )
    add_dependencies(${ARGUMENTS_TARGET} ${reflection_target})
endfunction()